ğŸ”¥ Challenges
ğŸ”¹ Challenge 1: Write a playbook to create multiple system users using a loop
ğŸ”¹ Challenge 2: Add a debug task to print the output of uname -a
ğŸ”¹ Challenge 3: Create a handler that restarts Nginx if a config file is changed
ğŸ”¹ Challenge 4: Use when to run tasks only on certain operating systems
ğŸ”¹ Challenge 5: Use tags to categorize tasks (install, config, restart)

ğŸ”¹ Challenge 6: Refactor a playbook using include_tasks or import_tasks
ğŸ”¹ Challenge 7: Create a main.yml file and use vars_files to separate configuration
ğŸ”¹ Challenge 8: Set up a playbook that creates a user, installs a package, and starts a service â€” all in one run
ğŸ”¹ Challenge 9: Add a rescue block to handle command failure gracefully
ğŸ”¹ Challenge 10: Create a reusable playbook role structure manually (without ansible-galaxy)

ğŸ”¹ Challenge 11: Set up a cron job using Ansible to schedule a periodic backup script.

ğŸ”¹ Challenge 12: Write a playbook to deploy a web app with Git clone, package install, config setup, and service start.

ğŸ”¹ Challenge 13: Configure firewall rules using Ansible (e.g., UFW on Ubuntu or firewalld on CentOS).

ğŸ”¹ Challenge 14: Automate SSL certificate generation using Letâ€™s Encrypt and deploy it to a web server.

ğŸ”¹ Challenge 15: Use Ansible to template configuration files with jinja2 and deploy them to remote hosts.

ğŸ”¹ Challenge 16: Deploy a multi-node application with dependencies (e.g., DB â†’ App Server â†’ Load Balancer).

ğŸ”¹ Challenge 17: Create an Ansible role that can be reused across projects (e.g., a â€œcommonâ€ role for all base configurations).

Here is a solution to each of the challenges you have outlined, using Ansible playbooks.

### ğŸ”¹ Challenge 1: Write a playbook to create multiple system users using a loop

```yaml
---
- name: Create multiple system users using a loop
  hosts: all
  become: yes
  tasks:
    - name: Create users
      user:
        name: "{{ item }}"
        state: present
      loop:
        - user1
        - user2
        - user3
        - user4
```

### ğŸ”¹ Challenge 2: Add a debug task to print the output of `uname -a`

```yaml
---
- name: Add a debug task to print the output of uname -a
  hosts: all
  tasks:
    - name: Run uname -a
      command: uname -a
      register: uname_output

    - name: Debug output of uname -a
      debug:
        msg: "{{ uname_output.stdout }}"
```

### ğŸ”¹ Challenge 3: Create a handler that restarts Nginx if a config file is changed

```yaml
---
- name: Ensure Nginx is configured properly
  hosts: all
  become: yes
  tasks:
    - name: Copy Nginx config file
      copy:
        src: /path/to/nginx.conf
        dest: /etc/nginx/nginx.conf
      notify:
        - Restart Nginx

  handlers:
    - name: Restart Nginx
      service:
        name: nginx
        state: restarted
```

### ğŸ”¹ Challenge 4: Use `when` to run tasks only on certain operating systems

```yaml
---
- name: Run tasks only on specific OS
  hosts: all
  tasks:
    - name: Install package for Debian-based OS
      apt:
        name: "{{ item }}"
        state: present
      when: ansible_facts['os_family'] == "Debian"
      loop:
        - package1
        - package2

    - name: Install package for RedHat-based OS
      yum:
        name: "{{ item }}"
        state: present
      when: ansible_facts['os_family'] == "RedHat"
      loop:
        - package1
        - package2
```

### ğŸ”¹ Challenge 5: Use tags to categorize tasks (install, config, restart)

```yaml
---
- name: Categorize tasks with tags
  hosts: all
  tasks:
    - name: Install package1
      apt:
        name: package1
        state: present
      tags:
        - install

    - name: Install package2
      apt:
        name: package2
        state: present
      tags:
        - install

    - name: Configure Nginx
      template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
      tags:
        - config

    - name: Restart Nginx
      service:
        name: nginx
        state: restarted
      tags:
        - restart
```

These are great challenges for enhancing your Ansible skills! Hereâ€™s how you can approach them one by one:

---

### ğŸ”¹ Challenge 6: Refactor a playbook using `include_tasks` or `import_tasks`

**Goal:** Refactor a playbook to break it down into smaller, reusable task files.

```yaml
# Original playbook (before refactoring)
---
- hosts: all
  tasks:
    - name: Install package
      apt:
        name: nginx
        state: present
    - name: Start service
      service:
        name: nginx
        state: started
```

**Refactored version using `include_tasks`:**

```yaml
# main.yml
---
- hosts: all
  tasks:
    - include_tasks: tasks/install_nginx.yml
    - include_tasks: tasks/start_nginx.yml
```

```yaml
# tasks/install_nginx.yml
---
- name: Install package
  apt:
    name: nginx
    state: present
```

```yaml
# tasks/start_nginx.yml
---
- name: Start service
  service:
    name: nginx
    state: started
```

In this example, the playbook is split into two separate task files: `install_nginx.yml` and `start_nginx.yml`, which makes the main playbook easier to maintain.

---

### ğŸ”¹ Challenge 7: Create a `main.yml` file and use `vars_files` to separate configuration

**Goal:** Separate variable files from the main playbook.

```yaml
# main.yml
---
- hosts: all
  vars_files:
    - vars/config.yml
  tasks:
    - name: Install package
      apt:
        name: "{{ package_name }}"
        state: present
    - name: Start service
      service:
        name: "{{ service_name }}"
        state: started
```

```yaml
# vars/config.yml
---
package_name: nginx
service_name: nginx
```

In this setup, variables are moved to a separate file `vars/config.yml`, and the main playbook `main.yml` refers to this file using `vars_files`. This helps in organizing and separating configuration from logic.

---

### ğŸ”¹ Challenge 8: Set up a playbook that creates a user, installs a package, and starts a service â€” all in one run

```yaml
# create_user_and_setup.yml
---
- hosts: all
  tasks:
    - name: Create a user
      user:
        name: johndoe
        state: present
        shell: /bin/bash

    - name: Install package
      apt:
        name: nginx
        state: present

    - name: Start service
      service:
        name: nginx
        state: started
```

This playbook creates a user named `johndoe`, installs the `nginx` package, and starts the `nginx` service, all in one execution.

---

### ğŸ”¹ Challenge 9: Add a rescue block to handle command failure gracefully

```yaml
# handle_failure.yml
---
- hosts: all
  tasks:
    - name: Try to install nginx
      apt:
        name: nginx
        state: present
      register: result
      ignore_errors: yes

    - name: Handle failure with rescue block
      block:
        - name: Notify failure
          debug:
            msg: "The installation of nginx failed!"
      rescue:
        - name: Print error message
          debug:
            msg: "Something went wrong, nginx installation failed!"
```

The `rescue` block allows you to handle task failures gracefully by notifying the user with a message.

---

### ğŸ”¹ Challenge 10: Create a reusable playbook role structure manually (without `ansible-galaxy`)

**Goal:** Create a role structure manually.

1. Create the following folder structure:

```
roles/
â””â”€â”€ myrole/
    â”œâ”€â”€ tasks/
    â”‚   â””â”€â”€ main.yml
    â”œâ”€â”€ handlers/
    â”‚   â””â”€â”€ main.yml
    â”œâ”€â”€ defaults/
    â”‚   â””â”€â”€ main.yml
    â”œâ”€â”€ vars/
    â”‚   â””â”€â”€ main.yml
    â”œâ”€â”€ files/
    â””â”€â”€ templates/
```

2. **Define tasks in `roles/myrole/tasks/main.yml`:**

```yaml
# roles/myrole/tasks/main.yml
---
- name: Install nginx
  apt:
    name: nginx
    state: present
```

3. **Create the playbook to call the role:**

```yaml
# playbook.yml
---
- hosts: all
  roles:
    - myrole
```

This structure allows you to maintain your playbooks in a modular, reusable way, even without using `ansible-galaxy`.

---

### ğŸ”¹ Challenge 11: Set up a cron job using Ansible to schedule a periodic backup script

```yaml
# setup_cron.yml
---
- hosts: all
  tasks:
    - name: Ensure backup cron job is present
      cron:
        name: "Backup Script"
        minute: "0"
        hour: "2"
        job: "/usr/local/bin/backup.sh"
        state: present
```

This playbook sets up a cron job that runs `/usr/local/bin/backup.sh` every day at 2:00 AM.

---

### ğŸ”¹ Challenge 12: Write a playbook to deploy a web app with Git clone, package install, config setup, and service start

```yaml
# deploy_web_app.yml
---
- hosts: web_servers
  tasks:
    - name: Clone the repository
      git:
        repo: "https://github.com/example/webapp.git"
        dest: "/var/www/webapp"
        version: "main"

    - name: Install dependencies
      apt:
        name:
          - python3
          - python3-pip
        state: present

    - name: Install Python packages
      pip:
        name: requirements.txt
        chdir: "/var/www/webapp"

    - name: Configure web app
      template:
        src: "config.j2"
        dest: "/var/www/webapp/config.py"

    - name: Start the web app service
      service:
        name: webapp
        state: started
```
Those are some great automation challenges you're tackling with Ansible! Let's break down each one of these challenges:

---

### ğŸ”¹ **Challenge 13: Configure firewall rules using Ansible (e.g., UFW on Ubuntu or firewalld on CentOS).**

**Objective**: You need to manage firewall configurations using Ansible on different distributions of Linux (Ubuntu for UFW, CentOS for firewalld).

**Example**:
- **UFW on Ubuntu**:
  You can use the `ufw` module in Ansible to configure UFW (Uncomplicated Firewall).

  ```yaml
  - name: Configure UFW rules
    hosts: ubuntu
    become: yes
    tasks:
      - name: Allow SSH
        ufw:
          rule: allow
          name: OpenSSH

      - name: Allow HTTP
        ufw:
          rule: allow
          name: 'Apache'

      - name: Enable UFW
        ufw:
          state: enabled
  ```

- **firewalld on CentOS**:
  For CentOS, youâ€™ll use the `firewalld` module.

  ```yaml
  - name: Configure firewalld rules
    hosts: centos
    become: yes
    tasks:
      - name: Allow HTTP service
        firewalld:
          service: http
          permanent: yes
          state: enabled

      - name: Allow SSH service
        firewalld:
          service: ssh
          permanent: yes
          state: enabled

      - name: Reload firewalld
        firewalld:
          state: reloaded
  ```

---

### ğŸ”¹ **Challenge 14: Automate SSL certificate generation using Letâ€™s Encrypt and deploy it to a web server.**

**Objective**: Use Ansible to automate SSL certificate issuance from Letâ€™s Encrypt and deploy it to a web server.

**Example**:
- Install the `certbot` package, generate the certificate, and configure your web server (e.g., Nginx or Apache).

  ```yaml
  - name: Automate SSL certificate generation with Let's Encrypt
    hosts: web_servers
    become: yes
    tasks:
      - name: Install certbot
        apt:
          name: certbot
          state: present
          update_cache: yes

      - name: Generate SSL certificate
        command: certbot certonly --standalone --non-interactive --agree-tos --email your-email@example.com -d yourdomain.com

      - name: Deploy SSL certificate to Nginx
        template:
          src: nginx_ssl.conf.j2
          dest: /etc/nginx/sites-available/default
        notify:
          - reload nginx

  handlers:
    - name: reload nginx
      service:
        name: nginx
        state: reloaded
  ```

- The `nginx_ssl.conf.j2` template should reference the certificates generated by certbot and set them in your Nginx configuration.

---

### ğŸ”¹ **Challenge 15: Use Ansible to template configuration files with jinja2 and deploy them to remote hosts.**

**Objective**: Leverage Ansible's templating capabilities to deploy configuration files using Jinja2.

**Example**:
- Suppose you're deploying a `nginx.conf` configuration file.

  ```yaml
  - name: Deploy Nginx configuration using Jinja2
    hosts: web_servers
    become: yes
    vars:
      server_name: "example.com"
    tasks:
      - name: Template nginx.conf file
        template:
          src: nginx.conf.j2
          dest: /etc/nginx/nginx.conf
        notify:
          - reload nginx
  ```

- Example of a **Jinja2 template (`nginx.conf.j2`)**:
  
  ```jinja
  server {
      listen 80;
      server_name {{ server_name }};
      
      location / {
          root /var/www/html;
          index index.html;
      }
  }
  ```

---

### ğŸ”¹ **Challenge 16: Deploy a multi-node application with dependencies (e.g., DB â†’ App Server â†’ Load Balancer).**

**Objective**: Use Ansible to deploy a multi-tier application where components have dependencies on each other.

**Example**:
- You may deploy a database, application server, and load balancer in the correct order, ensuring that dependencies are met.

  ```yaml
  - name: Deploy Multi-Node Application
    hosts: db_server
    become: yes
    tasks:
      - name: Install MySQL
        apt:
          name: mysql-server
          state: present

  - name: Deploy App Server
    hosts: app_servers
    become: yes
    tasks:
      - name: Install application packages
        apt:
          name: myapp
          state: present

      - name: Ensure app is running
        service:
          name: myapp
          state: started

  - name: Deploy Load Balancer
    hosts: load_balancer
    become: yes
    tasks:
      - name: Install HAProxy
        apt:
          name: haproxy
          state: present

      - name: Configure HAProxy load balancing
        template:
          src: haproxy.cfg.j2
          dest: /etc/haproxy/haproxy.cfg
        notify:
          - restart haproxy

  handlers:
    - name: restart haproxy
      service:
        name: haproxy
        state: restarted
  ```

---

### ğŸ”¹ **Challenge 17: Create an Ansible role that can be reused across projects (e.g., a â€œcommonâ€ role for all base configurations).**

**Objective**: Organize your Ansible code into reusable roles to avoid redundancy and make your playbooks modular.

**Example**:
- Let's create a `common` role that installs and configures basic packages (e.g., NTP, SSH, and common utilities).

**Directory structure for the `common` role**:
```
roles/
  common/
    tasks/
      main.yml
    defaults/
      main.yml
    handlers/
      main.yml
```

- **main.yml (tasks)**:

  ```yaml
  ---
  - name: Install common utilities
    apt:
      name:
        - ntp
        - vim
        - curl
      state: present

  - name: Configure SSH for root login
    lineinfile:
      path: /etc/ssh/sshd_config
      regexp: '^PermitRootLogin'
      line: 'PermitRootLogin yes'
    notify:
      - restart ssh
  ```

- **main.yml (handlers)**:

  ```yaml
  ---
  - name: restart ssh
    service:
      name: ssh
      state: restarted
  ```

- Now, in your playbook, you can reuse the `common` role.

  ```yaml
  - name: Configure common settings on all servers
    hosts: all
    roles:
      - common
  ```
