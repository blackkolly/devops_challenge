ğŸ”¥ Challenges
ğŸ”¹ Challenge 1: Create a deployment with 3 replicas using YAML
ğŸ”¹ Challenge 2: Add labels and annotations to the deployment and query using kubectl
ğŸ”¹ Challenge 3: Scale the deployment to 5 pods and back to 2

ğŸ”¹ Challenge 4: Perform a rolling update by changing the image tag
ğŸ”¹ Challenge 5: Rollback to the previous revision

ğŸ”¹ Challenge 6: Add readiness and liveness probes to your deployment
ğŸ”¹ Challenge 7: Add resources.requests and limits to containers
ğŸ”¹ Challenge 8: Add revisionHistoryLimit: 2 and inspect revision history
ğŸ”¹ Challenge 9: Simulate a failed deployment (use a wrong image) and troubleshoot
ğŸ”¹ Challenge 10: Use kubectl rollout pause and resume to control update rollout


ğŸ”¹ Challenge 11: Final Challenge, Web App Deployment

Build a deployment.yaml that:

Deploys a node or nginx app

Has 3 replicas

Includes readiness and liveness probes

Limits CPU to 250m and memory to 256Mi

Has proper labels, annotations, and revisionHistoryLimit

Uses RollingUpdate strategy with maxSurge and maxUnavailable defined

ğŸ“Œ Apply with kubectl apply -f deployment.yaml and verify rollout
ğŸ“Œ Break and rollback the deployment using kubectl set image and rollout undo

